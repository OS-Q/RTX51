/************************************************************
* 组织名称： (C), 1988-1999, Tech. Co., Ltd.
* 文件名称: test.cpp
* 作者:
* 版本 :
* 日期:
* 描述: // 模块描述
* 主要函数及其功能 : // 主要函数及其功能
  1. -------
* 历史修改记录: // 历史修改记录
* <作者> <时间> <版本 > <描述>
* David 96/10/12 1.0 build this moudle
***********************************************************/
#include    "PCA.h"
bit     B_Capture0,B_Capture1,B_Capture2;
u8      PCA0_mode,PCA1_mode,PCA2_mode;
u16     CCAP0_tmp,PCA_Timer0;
u16     CCAP1_tmp,PCA_Timer1;
u16     CCAP2_tmp,PCA_Timer2;
/*************  ????    **************
******************************************/
u16 PWM0_low;   //PWM??????PCA??????, ???????
u16 PWM1_low;   //PWM??????PCA??????, ???????
u16 PWM2_low;   //PWM??????PCA??????, ???????
//========================================================================
// ??: void PWMn_SetHighReg(unsigned int high)
// ??: ????????
// ??: high:    ?????,?PWM??????PCA???????
// ??: ?
// ??: VER1.0
// ??: 2013-5-15
// ??:
//========================================================================
void PWMn_Update(u8 PCA_id, u16 high)
{
    if(PCA_id == PCA0)
    {
        if(high > PWM0_HIGH_MAX)
        {
            high = PWM0_HIGH_MAX;    //?????????????,?????????
        }
        if(high < PWM0_HIGH_MIN)
        {
            high = PWM0_HIGH_MIN;    //?????????????,???????2?
        }
        CR = 0;                         //??PCA?
        PCA_Timer0 = high;              //???????,??????????
        PWM0_low = PWM0_DUTY - high;    //?????PWM??????PCA???????
        CR = 1;                         //??PCA?
    }
    else if(PCA_id == PCA1)
    {
        if(high > PWM1_HIGH_MAX)
        {
            high = PWM1_HIGH_MAX;    //?????????????,?????????
        }
        if(high < PWM1_HIGH_MIN)
        {
            high = PWM1_HIGH_MIN;    //?????????????,???????2?
        }
        CR = 0;                         //??PCA?
        PCA_Timer1 = high;              //???????,??????????
        PWM1_low = PWM1_DUTY - high;    //?????PWM??????PCA???????
        CR = 1;                         //??PCA?
    }
    else if(PCA_id == PCA2)
    {
        if(high > PWM2_HIGH_MAX)
        {
            high = PWM2_HIGH_MAX;    //?????????????,?????????
        }
        if(high < PWM2_HIGH_MIN)
        {
            high = PWM2_HIGH_MIN;    //?????????????,???????2?
        }
        CR = 0;                     //??PCA?
        PCA_Timer2 = high;                      //???????,??????????
        PWM2_low = PWM2_DUTY - high;                //?????PWM??????PCA???????
        CR = 1;                     //??PCA?
    }
}
//========================================================================
// ??: UpdatePwm(u8 PCA_id, u8 pwm_value)
// ??: ??PWM?.
// ??: PCA_id: PCA??. ?? PCA0,PCA1,PCA2,PCA_Counter
//       pwm_value: pwm?, ????????????.
// ??: none.
// ??: V1.0, 2012-11-22
//========================================================================
/*
void    UpdatePwm(u8 PCA_id, u8 pwm_value)
{
    if(PCA_id == PCA0)      CCAP0H = pwm_value;
    else if(PCA_id == PCA1) CCAP1H = pwm_value;
    else if(PCA_id == PCA2) CCAP2H = pwm_value;
}
*/
//========================================================================
// ??: void PCA_Init(PCA_id, PCA_InitTypeDef *PCAx)
// ??: PCA?????.
// ??: PCA_id: PCA??. ?? PCA0,PCA1,PCA2,PCA_Counter
//       PCAx: ????,???PCA.h????.
// ??: none.
// ??: V1.0, 2012-11-22
//========================================================================
void    PCA_Init(u8 PCA_id, PCA_InitTypeDef *PCAx)
{
    if(PCA_id > PCA_Counter)
    {
        return;    //id??
    }
    if(PCA_id == PCA_Counter)           //????Counter
    {
        CR = 0;
        CH = 0;
        CL = 0;
        AUXR1 = (AUXR1 & ~(3<<4)) | PCAx->PCA_IoUse;            //??IO?
        CMOD  = (CMOD  & ~(7<<1)) | PCAx->PCA_Clock;            //?????
        CMOD  = (CMOD  & ~1) | (PCAx->PCA_Interrupt_Mode & 1);  //ECF
        if(PCAx->PCA_Polity == PolityHigh)
        {
            PPCA = 1;    //??????
        }
        else
        {
            PPCA = 0;    //??????
        }
        CR = 1;
        return;
    }
    PCAx->PCA_Interrupt_Mode &= (3<<4) + 1;
    if(PCAx->PCA_Mode >= PCA_Mode_SoftTimer)
    {
        PCAx->PCA_Interrupt_Mode &= ~(3<<4);
    }
    if(PCA_id == PCA0)
    {
        CCAPM0    = PCAx->PCA_Mode | PCAx->PCA_Interrupt_Mode;  //????, ????
        PCA_PWM0  = (PCA_PWM0 & ~(3<<6)) | PCAx->PCA_PWM_Wide;  //PWM??
        PCA_Timer0 = PCAx->PCA_Value;
        B_Capture0 = 0;
        PCA0_mode = PCAx->PCA_Mode;
        CCAP0_tmp = PCA_Timer0;
        CCAP0L = (u8)CCAP0_tmp;         //?????????????,??CCAP0L
        CCAP0H = (u8)(CCAP0_tmp >> 8);  //??CCAP0H
    }
    if(PCA_id == PCA1)
    {
        CCAPM1    = PCAx->PCA_Mode | PCAx->PCA_Interrupt_Mode;
        PCA_PWM1  = (PCA_PWM1 & ~(3<<6)) | PCAx->PCA_PWM_Wide;
        PCA_Timer1 = PCAx->PCA_Value;
        B_Capture1 = 0;
        PCA1_mode = PCAx->PCA_Mode;
        CCAP1_tmp = PCA_Timer1;
        CCAP1L = (u8)CCAP1_tmp;         //?????????????,??CCAP0L
        CCAP1H = (u8)(CCAP1_tmp >> 8);  //??CCAP0H
    }
    if(PCA_id == PCA2)
    {
        CCAPM2    = PCAx->PCA_Mode | PCAx->PCA_Interrupt_Mode;
        PCA_PWM2  = (PCA_PWM2 & ~(3<<6)) | PCAx->PCA_PWM_Wide;
        PCA_Timer2 = PCAx->PCA_Value;
        B_Capture2 = 0;
        PCA2_mode = PCAx->PCA_Mode;
        CCAP2_tmp = PCA_Timer2;
        CCAP2L = (u8)CCAP2_tmp;         //?????????????,??CCAP0L
        CCAP2H = (u8)(CCAP2_tmp >> 8);  //??CCAP0H
    }
}
void pwmOutPut(u8 PCA_id,unsigned int T,unsigned int duty)
{
    if(PCA_id == PCA0)
    {
        if(duty > 100)
        {
            duty = 100;    //?????????????,?????????
        }
        if(duty < 1)
        {
            duty = 1;    //?????????????,???????2?
        }
        CR = 0;                         //??PCA?
        PCA_Timer0 = (unsigned int)(T*duty/100);                //???????,??????????
        PWM0_low =(unsigned int) (T*(1-(duty/100)));    //?????PWM??????PCA???????
        CR = 1;                         //??PCA?
    }
    else if(PCA_id == PCA1)
    {
        if(duty > 100)
        {
            duty = 100;    //?????????????,?????????
        }
        if(duty < 1)
        {
            duty = 1;    //?????????????,???????2?
        }
        CR = 0;                         //??PCA?
        PCA_Timer1 = T*(duty/100);              //???????,??????????
        PWM1_low = T*(1-(duty/100));    //?????PWM??????PCA???????
        CR = 1;                         //??PCA?
    }
    else if(PCA_id == PCA2)
    {
        if(duty > 100)
        {
            duty = 100;    //?????????????,?????????
        }
        if(duty < 1)
        {
            duty = 1;    //?????????????,???????2?
        }
        CR = 0;                     //??PCA?
        PCA_Timer2 = T*(duty/100);              //???????,??????????
        PWM2_low = T*(1-(duty/100));    //?????PWM??????PCA???????
        CR = 1;                     //??PCA?
    }
}
//========================================================================
// ??: void PCA_Handler (void) interrupt PCA_VECTOR
// ??: PCA??????.
// ??: None
// ??: none.
// ??: V1.0, 2012-11-22
//========================================================================
void    PCA_Handler (void) interrupt PCA_VECTOR
{
    if(CCF0)        //PCA??0??
    {
        CCF0 = 0;       //?PCA??0????
        if(P25)
        {
            CCAP0_tmp += PCA_Timer0;    //??????,????????????????
        }
        else
        {
            CCAP0_tmp += PWM0_low;    //??????,????????????????
        }
        CCAP0L = (u8)CCAP0_tmp;         //?????????????,??CCAP0L
        CCAP0H = (u8)(CCAP0_tmp >> 8);  //??CCAP0H
    }
    if(CCF1)    //PCA??1??
    {
        CCF1 = 0;       //?PCA??1????
        if(P26)
        {
            CCAP1_tmp += PCA_Timer1;    //??????,????????????????
        }
        else
        {
            CCAP1_tmp += PWM1_low;    //??????,????????????????
        }
        CCAP1L = (u8)CCAP1_tmp;         //?????????????,??CCAP0L
        CCAP1H = (u8)(CCAP1_tmp >> 8);  //??CCAP0H
    }
    if(CCF2)    //PCA??2??
    {
        CCF2 = 0;       //?PCA??1????
        if(P27)
        {
            CCAP2_tmp += PCA_Timer2;    //??????,????????????????
        }
        else
        {
            CCAP2_tmp += PWM2_low;    //??????,????????????????
        }
        CCAP2L = (u8)CCAP2_tmp;         //?????????????,??CCAP0L
        CCAP2H = (u8)(CCAP2_tmp >> 8);  //??CCAP0H
    }
    /*  if(CF)  //PCA????
        {
            CF = 0;         //?PCA??????
        }
    */
}
