/************************************************************
* 组织名称： (C), 1988-1999, Tech. Co., Ltd.
* 文件名称: test.cpp
* 作者:
* 版本 :
* 日期:
* 描述: // 模块描述
* 主要函数及其功能 : // 主要函数及其功能
  1. -------
* 历史修改记录: // 历史修改记录
* <作者> <时间> <版本 > <描述>
* David 96/10/12 1.0 build this moudle
***********************************************************/
/*************  功能说明    **************
本文件为STC15xxx系列的端口初始化程序,用户几乎可以不修改这个程序.
******************************************/
#include    "GPIO.h"
void setPinState(u8 Pin,bit State)
{
	 Pin=State;
	
	
}
//========================================================================
// 函数: u8 GPIO_Inilize(u8 GPIO, GPIO_InitTypeDef *GPIOx)
// 描述: 初始化IO口.
// 参数: GPIOx: 结构参数,请参考timer.h里的定义.
// 返回: 成功返回0, 空操作返回1,错误返回2.
// 版本: V1.0, 2012-10-22
//========================================================================
u8  GPIO_Inilize(u8 GPIO, GPIO_InitTypeDef *GPIOx)
{
    if(GPIO > GPIO_P5)
    {
        return 1;    //空操作
    }
    if(GPIOx->Mode > GPIO_OUT_PP)
    {
        return 2;    //错误
    }
    if(GPIO == GPIO_P0)
    {
        if(GPIOx->Mode == GPIO_PullUp)
        {
            P0M1 &= ~GPIOx->Pin,  P0M0 &= ~GPIOx->Pin;    //上拉准双向口
        }
        if(GPIOx->Mode == GPIO_HighZ)
        {
            P0M1 |=  GPIOx->Pin,  P0M0 &= ~GPIOx->Pin;    //浮空输入
        }
        if(GPIOx->Mode == GPIO_OUT_OD)
        {
            P0M1 |=  GPIOx->Pin,  P0M0 |=  GPIOx->Pin;    //开漏输出
        }
        if(GPIOx->Mode == GPIO_OUT_PP)
        {
            P0M1 &= ~GPIOx->Pin,  P0M0 |=  GPIOx->Pin;    //推挽输出
        }
    }
    if(GPIO == GPIO_P1)
    {
        if(GPIOx->Mode == GPIO_PullUp)
        {
            P1M1 &= ~GPIOx->Pin,  P1M0 &= ~GPIOx->Pin;    //上拉准双向口
        }
        if(GPIOx->Mode == GPIO_HighZ)
        {
            P1M1 |=  GPIOx->Pin,  P1M0 &= ~GPIOx->Pin;    //浮空输入
        }
        if(GPIOx->Mode == GPIO_OUT_OD)
        {
            P1M1 |=  GPIOx->Pin,  P1M0 |=  GPIOx->Pin;    //开漏输出
        }
        if(GPIOx->Mode == GPIO_OUT_PP)
        {
            P1M1 &= ~GPIOx->Pin,  P1M0 |=  GPIOx->Pin;    //推挽输出
        }
    }
    if(GPIO == GPIO_P2)
    {
        if(GPIOx->Mode == GPIO_PullUp)
        {
            P2M1 &= ~GPIOx->Pin,  P2M0 &= ~GPIOx->Pin;    //上拉准双向口
        }
        if(GPIOx->Mode == GPIO_HighZ)
        {
            P2M1 |=  GPIOx->Pin,  P2M0 &= ~GPIOx->Pin;    //浮空输入
        }
        if(GPIOx->Mode == GPIO_OUT_OD)
        {
            P2M1 |=  GPIOx->Pin,  P2M0 |=  GPIOx->Pin;    //开漏输出
        }
        if(GPIOx->Mode == GPIO_OUT_PP)
        {
            P2M1 &= ~GPIOx->Pin,  P2M0 |=  GPIOx->Pin;    //推挽输出
        }
    }
    if(GPIO == GPIO_P3)
    {
        if(GPIOx->Mode == GPIO_PullUp)
        {
            P3M1 &= ~GPIOx->Pin,  P3M0 &= ~GPIOx->Pin;    //上拉准双向口
        }
        if(GPIOx->Mode == GPIO_HighZ)
        {
            P3M1 |=  GPIOx->Pin,  P3M0 &= ~GPIOx->Pin;    //浮空输入
        }
        if(GPIOx->Mode == GPIO_OUT_OD)
        {
            P3M1 |=  GPIOx->Pin,  P3M0 |=  GPIOx->Pin;    //开漏输出
        }
        if(GPIOx->Mode == GPIO_OUT_PP)
        {
            P3M1 &= ~GPIOx->Pin,  P3M0 |=  GPIOx->Pin;    //推挽输出
        }
    }
    if(GPIO == GPIO_P4)
    {
        if(GPIOx->Mode == GPIO_PullUp)
        {
            P4M1 &= ~GPIOx->Pin,  P4M0 &= ~GPIOx->Pin;    //上拉准双向口
        }
        if(GPIOx->Mode == GPIO_HighZ)
        {
            P4M1 |=  GPIOx->Pin,  P4M0 &= ~GPIOx->Pin;    //浮空输入
        }
        if(GPIOx->Mode == GPIO_OUT_OD)
        {
            P4M1 |=  GPIOx->Pin,  P4M0 |=  GPIOx->Pin;    //开漏输出
        }
        if(GPIOx->Mode == GPIO_OUT_PP)
        {
            P4M1 &= ~GPIOx->Pin,  P4M0 |=  GPIOx->Pin;    //推挽输出
        }
    }
    if(GPIO == GPIO_P5)
    {
        if(GPIOx->Mode == GPIO_PullUp)
        {
            P5M1 &= ~GPIOx->Pin,  P5M0 &= ~GPIOx->Pin;    //上拉准双向口
        }
        if(GPIOx->Mode == GPIO_HighZ)
        {
            P5M1 |=  GPIOx->Pin,  P5M0 &= ~GPIOx->Pin;    //浮空输入
        }
        if(GPIOx->Mode == GPIO_OUT_OD)
        {
            P5M1 |=  GPIOx->Pin,  P5M0 |=  GPIOx->Pin;    //开漏输出
        }
        if(GPIOx->Mode == GPIO_OUT_PP)
        {
            P5M1 &= ~GPIOx->Pin,  P5M0 |=  GPIOx->Pin;    //推挽输出
        }
    }
    return 0;   //成功
}
